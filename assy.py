import sys
from charset import charmap

opcodes={"data": None, "rdata":	None, "sdata": None}
opcs="nop jmp hlt l lb li w wb inc dec out jeq jne and or xor add sub mul div wrt".split()
och=file("opcodes.h","wt")
och.write("// Automatically generated by assembler, do not edit.\n")
for i,o in enumerate(opcs):
	opcodes[o]=i
	och.write("#define %-20s %d\n"%("OP_"+o.upper(),i))
och.write("\nconst char *opnames[]={"+", ".join("\"%s\""%n for n in opcs)+"};\n")
och.close()


def err(msg):
	global lineNo,sline
	print "%-4d \"%s\""%(lineNo,sline)
	print "     "+msg
	sys.exit(1)

def makeInt(s):
	if s.startswith("0x"):
		try:
			return int(s[2:],16)
		except:
			pass
	if s.startswith("0"):
		try:
			return int(s[1:],8)
		except:
			pass
	if s.endswith("b") and len(s)>1:
		v=0
		for i,c in enumerate(s[:-1][::-1]):
			if c=="1":
				v|=1<<i
		return v&0xFFFF
	try:
		return int(s)
	except:
		pass
	return None
	
def makeIntF(s):
	i=makeInt(s)
	if i is None:
		err("Invalid integer \"%s\""%s)
	return i
	
def isReg(x):
	if x.startswith("$"):
		try:
			x=int(x[1:])
		except:
			return None
		if x<0 or x>7:
			return None
		return x
		
def isRegF(x):
	r=isReg(x)
	if r is None:
		err("Invalid register \"%s\""%x)
	return r

def splint(val):
	lo=val&0x00FF
	hi=(val&0xFF00)>>8
	return [hi,lo]

def putcodeint(offset,val):
	code[offset],code[offset+1]=splint(val)
	
def lfmt(f,*p):
	o=[]
	for i,c in enumerate(f):
		v=p[i]
		if c=="o":
			o.append(opcodes[v]&0xFF)
		elif c=="c":
			o.append(v&0xFF)
		elif c=="r":
			v=isRegF(v)
			o.append(v&0xFF)
		elif c=="i":
			if isinstance(v,basestring):
				v=makeInt(v)
			if v is None:
				err("invalid value")
			a,b=splint(v)
			o.append(a)
			o.append(b)
		elif c=="l":
			o.extend(intorlabel(*v))
	#print f,o
	return o

def intorlabel(val,n):
	iv=makeInt(val)
	if iv is not None:
		#print val,n,iv,iv+base
		return splint(iv)
	else:
		#print "Pushing label %s @ %d"%(val,len(code)+n)
		resTable[len(code)+n]=val
		return [0,0]

def handle_jmp(line):
	if len(line)<1:
		err("jmp <offset>")
	iv=makeInt(line[0])
	return lfmt("ol","jmp",(line[0],1))


def handle_l(line,op="l"):
	if len(line)<2:
		err("%s <register> <offset> [register]"%op)
	reg1=line[0]
	reg2=0
	if len(line)==3: reg2=line[2]
	return lfmt("orrl",op,reg1,reg2,(line[1],3))

def handle_lb(line):
	return handle_l(line,"lb")

def handle_w(line):
	return handle_l(line,"w")

def handle_wb(line):
	return handle_l(line,"wb")


def handle_tworeg(line,op):
	if len(line)<2:
		err("%s <regto> <regfr>"%op)
	return lfmt("orr",op,line[0],line[1])
	
def handle_and(line): return handle_tworeg(line,"and")
def handle_or(line): return handle_tworeg(line,"or")
def handle_xor(line): return handle_tworeg(line,"xor")

def handle_threereg(line,op):
	if len(line)<3:
		err("%s <regto> <regfr1> <regfr2>"%op)
	return lfmt("orrr",op,line[0],line[1],line[2])

def handle_23reg(line,op):
	if len(line)==2:
		return handle_threereg([line[0],line[0],line[1]],op)
	return handle_threereg(line,op)
	
def handle_add(line): return handle_23reg(line,"add")
def handle_sub(line): return handle_23reg(line,"sub")
def handle_mul(line): return handle_23reg(line,"mul")
def handle_div(line): return handle_23reg(line,"div")



def handle_li(line):
	if len(line)<2:
		err("li <register> <value>")
	return lfmt("ori","li",line[0],line[1])

def handle_inc(line):
	if len(line)<1: err("inc <register>")
	return lfmt("or","inc",line[0])

def handle_dec(line):
	if len(line)<1: err("dec <register>")
	return lfmt("or","dec",line[0])

def handle_out(line):
	if len(line)<2: err("out <port> <register>")
	port=makeIntF(line[0])&0xFF
	return lfmt("ocr","out",port,line[1])

def handle_jeq(line):
	if len(line)<3: err("jeq <register> == <register> ? <offset>")
	return lfmt("orrl","jeq",line[0],line[1],(line[2],3))

def handle_jne(line):
	if len(line)<3: err("jne <register> != <register> ? <offset>")
	return lfmt("orrl","jne",line[0],line[1],(line[2],3))

		
def handle_data(line):
	if len(line)<1:
		err("data <hex> [hex [hex...]]")
	try:
		dt=[int(c,16) for c in line if c]
	except Exception,e:
		err("invalid data")
	return dt

def handle_rdata(line):
	if len(line)<1:
		err("rdata <string>")
	return [ord(c) for c in " ".join(line)]

def handle_sdata(line):
	if len(line)<1:
		err("sdata <string>")
	o=[]
	d=" ".join(line).upper()
	for c in d:
		o.append(charmap.get(c,ord(c)))
	return o

f="default.asm"
if len(sys.argv)==2:
	f=sys.argv[1]

input=file(f).read()

addresses={}
resTable={}
code=[]
base=4096
lineNo=0
line=""
for lineNo,sline in enumerate(input.split("\n")):
	line=sline.strip()

	# Handle comments.
	if line.startswith(";") or line.startswith("#") or line=="":
		continue
	if "#" in line: line=line[:line.index("#")-1]
	if ";" in line: line=line[:line.index(";")-1]
	
	line=line.split()
	if line[0].endswith(":"):
		addr=line[0][:-1]
		if addr in addresses:
			err("duplicate label %s (previously defined at %d)",addr,addresses[addr])
		addresses[addr]=len(code)
		line=line[1:]
	opcode=line[0].lower()
	#print line#,code

	if "handle_"+opcode in globals():
		ret=(globals()["handle_"+opcode](line[1:]))
		if ret:
			#print ">>>",ret
			code.extend(ret)
	elif opcode in opcodes:
		code.append(opcodes[opcode])
	else:
		print "unrecognized opcode %s. skipping line #%d : %s"%(line[0],lineNo,line)
	#else:
	#	code.append(opcodes[opcode])		
for offset,label in resTable.iteritems():
	if label not in addresses:
		err("Undefined label %s (at %d)"%(label,offset))
	else:
		iv=addresses[label]+base
		putcodeint(offset,iv)
		#code[offset]=(iv&0xFF00)>>8
		#code[offset+1]=iv&0xFF
print "%d bytes of code."%len(code)
#code=[0]*base+code
f=open("default.md","wb")
f.write("".join(map(chr,code)))
f.close()
print "Wrote %d bytes with code offset %d."%(len(code),base)